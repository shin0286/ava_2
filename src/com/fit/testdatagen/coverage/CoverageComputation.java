package com.fit.testdatagen.coverage;

import java.util.ArrayList;
import java.util.List;

import com.fit.cfg.ICFG;
import com.fit.cfg.object.BeginFlagCfgNode;
import com.fit.cfg.object.EndFlagCfgNode;
import com.fit.cfg.object.ICfgNode;
import com.fit.cfg.object.ScopeCfgNode;
import com.fit.cfg.testpath.FullTestpath;
import com.fit.cfg.testpath.ITestpath;
import com.fit.instrument.FunctionInstrumentation;

/**
 * Abstract class for computing the coverage
 *
 * @author ducanhnguyen
 */
public abstract class CoverageComputation {
	protected ITestpath testpath = new FullTestpath();

	protected static final float MAXIMIZE_COVERAGE = 1f;
	protected static final int UNDEFINED_POSITION = -1;
	protected float coverage = 0.0f;

	/**
	 * Compute coverage
	 *
	 * @param testpath
	 *            the test path generated by executing function under test data
	 * @param cfg
	 *            the control flow graph of the function
	 */
	public abstract void findTestpath(String[] testpath, ICFG cfg);

	/**
	 * Get next normal statement from a specific location
	 *
	 * @param testpath
	 * @param currentPosition
	 * @return
	 */
	public int getNextNormalPosition(String[] testpath, int currentPosition) {
		int nextPosition = currentPosition;
		while (nextPosition < testpath.length && (testpath[nextPosition].equals(BeginFlagCfgNode.BEGIN_FLAG)
				|| testpath[nextPosition].equals(EndFlagCfgNode.END_FLAG)
				|| testpath[nextPosition].equals(ScopeCfgNode.SCOPE_CLOSE)
				|| testpath[nextPosition].equals(ScopeCfgNode.SCOPE_OPEN)))
			nextPosition++;

		if (nextPosition < testpath.length)
			return nextPosition;
		else
			return UNDEFINED_POSITION;
	}

	/**
	 * Find next cfg node based on the content of two next node
	 *
	 * @param currentCfgNode
	 *            Current cfg node
	 * @param nextContent
	 *            the next content on the given test path
	 * @param nextContentLevel2
	 *            the next of the next content on the given test path
	 * @return
	 */
	public ICfgNode findNextCfgNode(ICfgNode currentCfgNode, String nextContent, String nextContentLevel2) {
		ICfgNode next = null;

		if (currentCfgNode.isCondition())
			next = findNextCfgNodefromConditon(currentCfgNode, nextContent, nextContentLevel2);
		else
			next = findNextCfgNodeByContent(currentCfgNode.getTrueNode(), nextContent);
		return next;
	}

	private ICfgNode findNextCfgNodefromConditon(ICfgNode currentCfgNode, String nextContent,
			String nextContentLevel2) {
		ICfgNode next = null;

		ICfgNode tmp = currentCfgNode;
		/*
		 * Find the next node toward to true branch
		 */
		ICfgNode next1 = findNextCfgNodeByContent(currentCfgNode.getTrueNode(), nextContent);
		/*
		 * Find the next node toward to false branch
		 */
		ICfgNode next2 = findNextCfgNodeByContent(currentCfgNode.getFalseNode(), nextContent);

		/*
		 * The next node is only one!
		 * 
		 * Ex: if (x>0) x--; else x=x+1;
		 */
		if (next1 != null && next2 == null) {
			next = next1;
			testpath.cast().addAll(storeSpecialVertex(tmp.getTrueNode(), nextContent));
		}

		else if (next1 == null && next2 != null) {
			next = next2;
			testpath.cast().addAll(storeSpecialVertex(tmp.getFalseNode(), nextContent));
		}

		else if (next1 != null && next2 != null)
			if (nextContentLevel2 != null)
				/*
				 * We found two next nodes are candidates.
				 * 
				 * Ex: if (x>0) x--; else x--;
				 * 
				 * Ex: if (x>0) x = x-1; else x = x-1;
				 */
				if (next1.getTrueNode().getContent().equals(nextContentLevel2)
						|| next1.getFalseNode().getContent().equals(nextContentLevel2)) {
					next = next1;
					testpath.cast().addAll(storeSpecialVertex(tmp.getTrueNode(), nextContent));
				} else {
					next = next2;
					testpath.cast().addAll(storeSpecialVertex(tmp.getFalseNode(), nextContent));
				}
		return next;
	}

	public List<ICfgNode> storeSpecialVertex(ICfgNode currentCfgNode, String contentNextVertex) {
		List<ICfgNode> nodes = new ArrayList<>();
		while (currentCfgNode != null && currentCfgNode.isSpecialCfgNode()) {
			if (testpath.cast().size() >= 1
					&& testpath.cast().get(testpath.cast().size() - 1).getId() != currentCfgNode.getId())
				testpath.cast().add(currentCfgNode);
			currentCfgNode = currentCfgNode.getTrueNode();
		}
		return nodes;
	}

	/**
	 * Starting find vertex by its content from a specified vertex
	 *
	 * @param currentCfgNode
	 *            the vertex is not a condition
	 * @param contentNextVertex
	 * @return
	 */
	public ICfgNode findNextCfgNodeByContent(ICfgNode currentCfgNode, String contentNextVertex) {
		while (currentCfgNode != null && currentCfgNode.isSpecialCfgNode()) {
			currentCfgNode = currentCfgNode.getTrueNode();
		}

		/*
		 * The content in test path is normalized in FunctionInstrumentation class.
		 */
		if (currentCfgNode != null) {
			String noBreakLineContent = FunctionInstrumentation.replaceBreakLine(currentCfgNode.getContent());

			if (noBreakLineContent.equals(contentNextVertex))
				return currentCfgNode;

			else
				return null;
		} else
			return null;

	}

	public float getCoverage() {
		return coverage;
	}

	public void setCoverage(float coverage) {
		this.coverage = coverage;
	}

	public ITestpath getTestpath() {
		return testpath;
	}
}
