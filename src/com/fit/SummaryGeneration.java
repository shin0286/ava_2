package com.fit;

import com.fit.cfg.CFGGenerationforBranchvsStatementCoverage;
import com.fit.cfg.ICFG;
import com.fit.cfg.ICFGGeneration;
import com.fit.cfg.object.*;
import com.fit.cfg.testpath.*;
import com.fit.config.Bound;
import com.fit.config.FunctionConfig;
import com.fit.config.ISettingv2;
import com.fit.externalvariable.ReducedExternalVariableDetecter;
import com.fit.normalizer.FunctionNormalizer;
import com.fit.normalizer.UnaryNormalizer;
import com.fit.parser.projectparser.ProjectParser;
import com.fit.testdatagen.loop.PossibleTestpathGenerationForLoop;
import com.fit.testdatagen.se.*;
import com.fit.testdatagen.se.memory.ISymbolicVariable;
import com.fit.testdatagen.se.memory.VariableNodeTable;
import com.fit.tree.object.FunctionNode;
import com.fit.tree.object.IFunctionNode;
import com.fit.tree.object.INode;
import com.fit.tree.object.IVariableNode;
import com.fit.utils.Utils;
import com.fit.utils.search.FunctionNodeCondition;
import com.fit.utils.search.Search;
import org.apache.log4j.Logger;
import org.eclipse.cdt.core.dom.ast.IASTNode;
import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTFunctionDefinition;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.File;
import java.util.*;

import static com.fit.testdatagen.se.ISymbolicExecution.*;

public class SummaryGeneration {
    final static Logger logger = Logger.getLogger(SummaryGeneration.class);

    protected IFunctionNode functionNode;

    /**
     * Represent a test path generated from control flow graph
     */
    protected ITestpath testpath = null;

    /**
     * The variable passing to the function
     */
    protected Parameter paramaters = null;

    /**
     * Table of variables
     */
    protected VariableNodeTable tableMapping = new VariableNodeTable();

    /**
     * Store path constraints generated by performing symbolic execution the given
     * test path
     */

    /**
     * The return value of a test path, specified by "return ..."
     */
    private List<ICfgNode> listCfgNode;

    private HashMap<String,Integer> cfgMap = new HashMap<>();

    public String externalParameterFile;

    public String summaryFile;

    public SummaryGeneration (String projectPath, String functionName) throws Exception{
        ProjectParser parser = new ProjectParser(new File(projectPath));
        IFunctionNode function = (IFunctionNode) Search
                .searchNodes(parser.getRootTree(), new FunctionNodeCondition(), functionName).get(0);
//        System.out.println(function.getAST().getRawSignature());
//        logger.debug(function.getAST().getRawSignature());

        FunctionConfig functionConfig = new FunctionConfig();
        functionConfig.setCharacterBound(new Bound(30, 120));
        functionConfig.setIntegerBound(new Bound(10, 200));
        functionConfig.setSizeOfArray(5);
        functionConfig.setMaximumInterationsForEachLoop(1);
        functionConfig.setSolvingStrategy(ISettingv2.SUPPORT_SOLVING_STRATEGIES[0]);
        function.setFunctionConfig(functionConfig);

        // Normalize function
        FunctionNormalizer fnNormalizer = function.normalizedASTtoInstrument();
        String [] projectPathComponent = projectPath.split("\\");
        String projectName = projectPathComponent[projectPathComponent.length-1];
        summaryFile = projectPath + projectName + "_summary";
        externalParameterFile = projectPath + projectName + "_externVariable.xml"

        String newFunctionInStr = fnNormalizer.getNormalizedSourcecode();
        ICPPASTFunctionDefinition newAST = Utils.getFunctionsinAST(newFunctionInStr.toCharArray()).get(0);
        ((FunctionNode) function).setAST(newAST);
        writeSummaryToFile(summaryFile, projectPath, function, functionName);

    }

    public static void main(String[] args) throws Exception {
        SummaryGeneration sm = new SummaryGeneration("F:\\New folder\\ava_ver2\\data-test\\tsdv\\Sample_for_R1_2\\","mmin3(int,int,int)");
    }

    public void writeSummaryToFile(String sumFilepath, String sourceFilePath, IFunctionNode function, String functionName) throws Exception{
        String summary = "";
        if (Utils.containsLoopBlock(function) == true)
            summary = generateSummaryForLoop(function);
        else
            summary = generateSummaryOfAllSimpleTestpath(function);
        writeToXml(sumFilepath, sourceFilePath, functionName, summary);
        System.out.println(summary);
    }


    public void writeToXml(String sumFilepath, String sourceFilePath, String functionName, String summary) throws Exception{
        File file = new File(sumFilepath);
        Document doc = null;
        Element root = null;
        if (!file.exists()) {
            doc = DocumentBuilderFactory.newInstance().
                    newDocumentBuilder().newDocument();
            root = doc.createElement("project-summaries");
            doc.appendChild(root);
        } else {
            doc = DocumentBuilderFactory.newInstance().
                    newDocumentBuilder().parse(file);
            root = doc.getDocumentElement();
        }
        Element function = doc.createElement("function");
        root.appendChild(function);

        Element location = doc.createElement("location");
        location.appendChild(doc.createTextNode(sourceFilePath));
        function.appendChild(location);

        Element name = doc.createElement("name");
        name.appendChild(doc.createTextNode(functionName));
        function.appendChild(name);

        Element sum = doc.createElement("summary");
        sum.appendChild(doc.createTextNode(summary));
        function.appendChild(sum);

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");
        DOMSource source = new DOMSource(doc);
        StreamResult result = new StreamResult(file);
        transformer.transform(source, result);
    }

    String generateSummaryOfAllSimpleTestpath (IFunctionNode function) throws Exception{
        String returnType = function.getAST().getChildren()[0].getRawSignature();
        String summary = "";
        if (returnType.equals("void")){
            summary = function.getAST().getChildren()[2].getRawSignature();
        } else {
            PossibleTestpathGeneration tpGen = new PossibleTestpathGeneration(
                    new CFGGenerationforBranchvsStatementCoverage(function, ICFGGeneration.SEPARATE_FOR_INTO_SEVERAL_NODES)
                            .generateCFG(),
                    function.getFunctionConfig().getMaximumInterationsForEachLoop());
            tpGen.generateTestpaths();
            FullTestpaths testpath = tpGen.getPossibleTestpaths();

            Parameter paramaters = new Parameter();
            for (INode n : ((FunctionNode) function).getArguments())
                paramaters.add(n);
            for (INode n : ((FunctionNode) function).getReducedExternalVariables())
                paramaters.add(n);

            int numOfPath = testpath.size();
            System.out.println("num " + numOfPath);
            for (int i=0; i<numOfPath; i++) {
                IFullTestpath randomTestpath = testpath.get(i);
                ArrayList<String> constraintList = generateSummaryOfATestpath(randomTestpath, paramaters, function);
                int numOfConstraint = constraintList.size();
                if (i < numOfPath-1 && constraintList.get(numOfConstraint-1).contains("return")) {
                    String postCond = constraintList.get(numOfConstraint-1);
                    postCond = postCond.replace("return", "");
                    postCond = postCond.replace(";", "");
                    String pathSum = constraintList.get(numOfConstraint-2) + "?" + postCond + ":";
                    summary += pathSum;
                }
            }
            ArrayList<String> constraintList = generateSummaryOfATestpath(testpath.get(numOfPath-1), paramaters, function);
            String postCond = constraintList.get(constraintList.size()-1);
            postCond = postCond.replace("return", "");
            postCond = postCond.replace(";", "");
            summary = summary + postCond;
        }
        return summary;
    }

    private void replaceParameter(String parameter, String localValue){
        boolean isDef = false;
        for (int j=0; j<listCfgNode.size(); j++){
            ICfgNode cfgNode = listCfgNode.get(j);
            String node = cfgNode.getContent();
            if (node.contains(parameter + " ")){
                int statementType = cfgMap.get(node);
                if (cfgMap.get(node) == BINARY_ASSIGNMENT && node.indexOf(parameter) < node.indexOf('=')){
                    isDef = true;
                    localValue = (node.split("="))[1];
                    localValue = localValue.replace(" ", "");
                } else if (cfgMap.get(node) == CONDITION && isDef == true){
                    node = node.replace(parameter, localValue);
                    cfgMap.put(node,statementType);
                    listCfgNode.get(j).setContent(node);
                } else if (cfgMap.get(node) == RETURN){
                    String returnValue = node.split(" ")[1];
                    node = node.replace(returnValue, localValue);
                    cfgMap.put(node,statementType);
                    listCfgNode.get(j).setContent(node);
                }
            }
        }
    }

    public void replaceUsedParameter(ArrayList<String> localParam, ArrayList<String> instanceParam) {
        String localValue = "";
        for (String param : instanceParam){
            replaceParameter(param, localValue);
        }
        for (String param : localParam){
            replaceParameter(param, localValue);
        }
    }

    void replaceExternalVariable(IFunctionNode function) throws Exception{
        ReducedExternalVariableDetecter externalVariable = new ReducedExternalVariableDetecter(function);
        List<IVariableNode> externalVariables = function.getReducedExternalVariables();
        HashMap<String, String> externalVarMap = new HashMap<>();
        ArrayList<String> externalVarList = new ArrayList<>();
        for (INode node : externalVariables){
            externalVarMap.put(node.getName(), node.getAbsolutePath());
            externalVarList.add(node.getName());
        }
        File xmlFile = new File(externalParameterFile);
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
        Document document = documentBuilder.parse(xmlFile);

        document.getDocumentElement().normalize();
        NodeList varList = document.getElementsByTagName("extern-var");
        for (int i=0; i<varList.getLength(); i++) {
            Node varNode = varList.item(i);
            if (varNode.getNodeType() == Node.ELEMENT_NODE) {
                Element varElement = (Element) varNode;
                String varName = varElement.getElementsByTagName("name").item(0).getTextContent();
                String varPath = varElement.getElementsByTagName("location").item(0).getTextContent();
                if (externalVarMap.containsKey(varName) && externalVarMap.get(varName).equals(varPath)){
                    String externValue = ((varElement.getElementsByTagName("value").item(0).getTextContent()).split(","))[0];
                    replaceParameter(varName, externValue);
                }
            }
        }
    }

    public ArrayList<String> generateSummaryOfATestpath (IFullTestpath testpath, Parameter paramaters, IFunctionNode function) throws Exception {

        ArrayList<String> preCond = new ArrayList<>();

        ArrayList<String> localParam = new ArrayList<>();

        ArrayList<String> instanceParam = new ArrayList<>();

        ArrayList<String> externParam = new ArrayList<>();

        INormalizedTestpath normalizedTestpath = null;
        if (testpath instanceof INormalizedTestpath)
            normalizedTestpath = (INormalizedTestpath) testpath;
        else {
            UnaryNormalizer tpNormalizer = new UnaryNormalizer();
            tpNormalizer.setOriginalTestpath(testpath);
            tpNormalizer.normalize();
            normalizedTestpath = tpNormalizer.getNormalizedTestpath();
        }

        listCfgNode = normalizedTestpath.getAllCfgNodes();

        SymbolicExecution se = new SymbolicExecution(testpath, paramaters, function);

        String postCond = "";

        for (ICfgNode cfgNode : listCfgNode) {
            if (!se.isAlwaysFalse())
                if (cfgNode instanceof BeginFlagCfgNode || cfgNode instanceof EndFlagCfgNode) {
                    // nothing to do
                } else
                    try {
                        if (cfgNode instanceof NormalCfgNode) {
                            IASTNode ast = ((NormalCfgNode) cfgNode).getAst();
                            int statementType = se.getStatementType(ast);
                            cfgMap.put(ast.getRawSignature(), statementType);
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                        break;
                    }
        }
        VariableNodeTable tableMapping = (VariableNodeTable) se.getTableMapping();
        for (int i = 0; i < tableMapping.size(); i++) {
            ISymbolicVariable symbolicVariable = tableMapping.getVariables().get(i);
            if (symbolicVariable.getScopeLevel() == 2 && externParam.contains(symbolicVariable.getName()) == false) {
                localParam.add(symbolicVariable.getName());
            } else if (symbolicVariable.getScopeLevel() == 0){
                instanceParam.add(symbolicVariable.getName());
            }

        }

        if (!se.isAlwaysFalse()) {
            replaceUsedParameter(localParam, instanceParam);
            replaceExternalVariable(function);
            for (ICfgNode cfgNode : listCfgNode) {
                if (cfgNode instanceof BeginFlagCfgNode || cfgNode instanceof EndFlagCfgNode) {
                    // nothing to do
                } else
                    try {
                        if (cfgNode instanceof NormalCfgNode) {
                            String node = cfgNode.getContent();
                            if (cfgMap.get(node) != CONDITION) {
                                if (cfgMap.get(node) == RETURN) {
                                    postCond = node;
                                }
                            } else {
                                if (cfgMap.get(node) == CONDITION)
                                    preCond.add(node);
                            }
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                        break;
                    }
            }
//            System.out.println(listCfgNode);
            String _preCond = "(" + preCond.get(0);
            for (int i = 1; i < preCond.size(); i++) {
                _preCond = _preCond + " && " + preCond.get(i);
            }
            _preCond = _preCond + ")";
            preCond.add(_preCond);
            preCond.add(postCond);
            System.out.println("post cond " + postCond);
        }
        return preCond;
    }
    public String generateSummaryForLoop (IFunctionNode function) throws Exception{
        CFGGenerationforBranchvsStatementCoverage cfgGen = new CFGGenerationforBranchvsStatementCoverage(function, ICFGGeneration.SEPARATE_FOR_INTO_SEVERAL_NODES);
        ICFG cfg = cfgGen.generateCFG();
        cfg.setFunctionNode(function);
        cfg.setIdforAllNodes();
        cfg.resetVisitedState();
        AbstractConditionLoopCfgNode loopCondition = (AbstractConditionLoopCfgNode) cfg
                .findFirstCfgNodeByContent("a<5");
        PossibleTestpathGenerationForLoop tpGen = new PossibleTestpathGenerationForLoop(cfg, loopCondition);
        tpGen.setIterationForUnboundedTestingLoop(3);
        tpGen.setMaximumIterationsForOtherLoops(0);
        tpGen.generateTestpaths();

        return null;
    }
}

