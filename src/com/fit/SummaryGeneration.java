package com.fit;

import com.fit.cfg.CFGGenerationforBranchvsStatementCoverage;
import com.fit.cfg.ICFGGeneration;
import com.fit.cfg.object.*;
import com.fit.cfg.testpath.IFullTestpath;
import com.fit.cfg.testpath.INormalizedTestpath;
import com.fit.cfg.testpath.ITestpath;
import com.fit.cfg.testpath.PossibleTestpathGeneration;
import com.fit.config.Bound;
import com.fit.config.FunctionConfig;
import com.fit.config.ISettingv2;
import com.fit.normalizer.FunctionNormalizer;
import com.fit.normalizer.UnaryNormalizer;
import com.fit.parser.projectparser.ProjectParser;
import com.fit.testdatagen.AbstractTestdataGeneration;
import com.fit.testdatagen.se.*;
import com.fit.testdatagen.se.memory.ISymbolicVariable;
import com.fit.testdatagen.se.memory.VariableNodeTable;
import com.fit.testdatagen.se.normalstatementparser.BinaryAssignmentParser;
import com.fit.testdatagen.se.normalstatementparser.ThrowParser;
import com.fit.testdatagen.se.normalstatementparser.UnaryBinaryParser;
import com.fit.testdatagen.se.normalstatementparser.UsingNamespaceParser;
import com.fit.tree.object.FunctionNode;
import com.fit.tree.object.IFunctionNode;
import com.fit.tree.object.INode;
import com.fit.utils.Utils;
import com.fit.utils.search.FunctionNodeCondition;
import com.fit.utils.search.Search;
import org.apache.log4j.Logger;
import org.eclipse.cdt.core.dom.ast.IASTExpression;
import org.eclipse.cdt.core.dom.ast.IASTNode;
import org.eclipse.cdt.core.dom.ast.IASTReturnStatement;
import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTFunctionDefinition;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static com.fit.testdatagen.se.ISymbolicExecution.*;

public class SummaryGeneration {
    final static Logger logger = Logger.getLogger(SummaryGeneration.class);

    protected IFunctionNode functionNode;

    /**
     * Represent a test path generated from control flow graph
     */
    protected ITestpath testpath = null;

    /**
     * The variable passing to the function
     */
    protected Parameter paramaters = null;

    /**
     * Table of variables
     */
    protected VariableNodeTable tableMapping = new VariableNodeTable();

    /**
     * Store path constraints generated by performing symbolic execution the given
     * test path
     */
    protected PathConstraints constraints = new PathConstraints();

    /**
     * The return value of a test path, specified by "return ..."
     */
    protected String returnValue = "";

    public List<ICfgNode> listCfgNode;

    public SummaryGeneration (ITestpath testpath){

    }

    public static void main(String[] args) throws Exception {
        ProjectParser parser = new ProjectParser(new File("F:\\New folder\\ava_ver2\\data-test\\tsdv\\Sample_for_R1_2\\"));
        IFunctionNode function = (IFunctionNode) Search
                .searchNodes(parser.getRootTree(), new FunctionNodeCondition(), "mmin3(int,int,int)").get(0);
        System.out.println(function.getAST().getRawSignature());
        logger.debug(function.getAST().getRawSignature());

        FunctionConfig functionConfig = new FunctionConfig();
        functionConfig.setCharacterBound(new Bound(30, 120));
        functionConfig.setIntegerBound(new Bound(10, 200));
        functionConfig.setSizeOfArray(5);
        functionConfig.setMaximumInterationsForEachLoop(1);
        functionConfig.setSolvingStrategy(ISettingv2.SUPPORT_SOLVING_STRATEGIES[0]);
        function.setFunctionConfig(functionConfig);

        // Normalize function
        FunctionNormalizer fnNormalizer = function.normalizedASTtoInstrument();

        String newFunctionInStr = fnNormalizer.getNormalizedSourcecode();
        ICPPASTFunctionDefinition newAST = Utils.getFunctionsinAST(newFunctionInStr.toCharArray()).get(0);
        ((FunctionNode) function).setAST(newAST);

        // Choose a random test path to test
        PossibleTestpathGeneration tpGen = new PossibleTestpathGeneration(
                new CFGGenerationforBranchvsStatementCoverage(function, ICFGGeneration.SEPARATE_FOR_INTO_SEVERAL_NODES)
                        .generateCFG(),
                function.getFunctionConfig().getMaximumInterationsForEachLoop());
        tpGen.generateTestpaths();
        logger.debug("num tp = " + tpGen.getPossibleTestpaths().size());
        IFullTestpath randomTestpath = tpGen.getPossibleTestpaths().get(0);
        logger.debug(randomTestpath);

        // Get the passing variables of the given function
        Parameter paramaters = new Parameter();
        for (INode n : ((FunctionNode) function).getArguments())
            paramaters.add(n);
        for (INode n : ((FunctionNode) function).getReducedExternalVariables())
            paramaters.add(n);
//        SummaryGeneration sg = new SummaryGeneration();

    }

    public String generateSummaryOfATestpath (IFullTestpath testpath) throws Exception {
        INormalizedTestpath normalizedTestpath = null;
        if (testpath instanceof INormalizedTestpath)
            normalizedTestpath = (INormalizedTestpath) testpath;
        else {
            UnaryNormalizer tpNormalizer = new UnaryNormalizer();
            tpNormalizer.setOriginalTestpath(testpath);
            tpNormalizer.normalize();
            normalizedTestpath = tpNormalizer.getNormalizedTestpath();
        }

        listCfgNode = normalizedTestpath.getAllCfgNodes();

        List<String> constraints = new ArrayList<>();

        SymbolicExecution se = new SymbolicExecution(testpath);
        // STEP 2.
        // We perform the symbolic execution on all of the statements in the normalized
        // test path until catch an supported statement.
        for (ICfgNode cfgNode : normalizedTestpath.getAllCfgNodes())
            // If the test path is always false, we stop the symbolic execution.
            if (!this.constraints.isAlwaysFalse())
                if (cfgNode instanceof BeginFlagCfgNode || cfgNode instanceof EndFlagCfgNode) {
                    // nothing to do
                } else
                    try {
                        boolean isContinue = true;

                        if (cfgNode instanceof NormalCfgNode) {
                            IASTNode ast = ((NormalCfgNode) cfgNode).getAst();
                            switch (se.getStatementType(ast)) {
                                case NAMESPACE:

                                case UNARY_ASSIGNMENT: {

                                }
                                case BINARY_ASSIGNMENT: {

                                }

                                case DECLARATION: {

                                }

                                case CONDITION: {

                                }

                                case RETURN: {

                                }

                                case THROW: {

                                }

                                case IGNORE:
                                    break;

                                case UNSPECIFIED_STATEMENT:
                                    break;
                            }
                        } else if (cfgNode instanceof ScopeCfgNode){

                        } else if (cfgNode instanceof FlagCfgNode) {
                            // nothing to do
                        } else
                            break;

                        if (!isContinue)
                            break;
                    } catch (Exception e) {
                        e.printStackTrace();
                        break;
                    }
        return "";
    }
}
